#!/usr/bin/perl

# TODO refresh
# TODO check http return codes
# TODO display success message after uploading
# TODO getline history
# TODO o - open in browser
# TODO c - open new wiki/projekt
# TODO RET - view page
# TODO projects api

use Mojo::Base -strict, -signatures;
use Mojo::URL;
use Mojo::UserAgent;
use Mojo::File 'tempfile';
use Mojo::Util 'decode', 'encode';

use Curses;

use App::pickaxe::Getline 'getline';
use App::pickaxe::AskYesNo 'askyesno';
use App::pickaxe::DisplayMsg 'display_msg';
use App::pickaxe::Pager 'pager';
use App::pickaxe::Api 'get', 'put';

my $ua   = Mojo::UserAgent->new;
my $base = Mojo::URL->new('https://example.com/projects/foo/');

my $selected     = 0;
my $list_maxrows = 0;
my @pages;
my $pad;
my $echobar;

my %bindings = (
    Curses::KEY_DOWN  => 'next_item',
    Curses::KEY_UP    => 'prev_item',
    n                 => 'next_item',
    p                 => 'prev_item',
    e                 => 'edit_page',
    "\n"              => 'view_page',
    Curses::KEY_NPAGE => 'next_page',
    Curses::KEY_PPAGE => 'prev_page',
    Curses::KEY_LEFT  => 'prev_page',
    Curses::KEY_RIGHT => 'next_page',
    s                 => 'search',
    '?'               => 'display_help',
    q                 => 'quit',
);

sub list_pages {
    my $res = eval { get( $base->clone->path("wiki/index.json") ) };
    if ($@) {
        endwin;
        die "Error connection server: " . $@ . "\n";
    }
    if ( !$res->is_success ) {
        endwin;
        die "Error connection server: " . $res->message . "\n";
    }
    return @{ $res->json->{wiki_pages} };
}

sub create_pad (@pages) {
    if ( !@pages ) {
        return;
    }
    my $pad = newpad( scalar @pages, $COLS );
    for my $page (@pages) {
        $pad->addstring( $page->{title} . "\n" );
    }
    return $pad;
}

sub update_helpbar {
    move( 0, 0 );
    clrtoeol;
    attron(A_REVERSE);
    my $help = "q:Quit e:Edit s:Search ?:help";
    addstring( $help . ( ' ' x ( $COLS - length($help) ) ) );
    attroff(A_REVERSE);
    refresh;
}

sub update_statusbar {
    move( $LINES - 2, 0 );
    clrtoeol;
    attron(A_REVERSE);
    my $base   = $base->clone->query( key => undef );
    my $status = "pickaxe: $base";
    addstring( $status . ( ' ' x ( $COLS - length($status) ) ) );
    attroff(A_REVERSE);
    refresh;
}

sub update_pad ($clear) {
    return if !$pad;
    chgat( $pad, $selected, 0, -1, A_REVERSE, 0, 0 );

    my $offset = int( $selected / $list_maxrows ) * $list_maxrows;
    if ($clear) {
        clear;
        update_statusbar;
        update_helpbar;
        refresh;
    }
    prefresh( $pad, $offset, 0, 1, 0, $LINES - 3, $COLS - 1 );
}

sub main {

    initscr;
    keypad( stdscr, 1 );
    noecho;
    curs_set(0);
    refresh;    # This is the necessary but undocumented initial refresh

    $echobar = subwin( $stdscr, 1, $COLS, $LINES - 1, 0 );
    update_statusbar;
    update_helpbar;

    if ( $ENV{REDMINE_APIKEY} ) {
        $base->query( key => $ENV{REDMINE_APIKEY} );
    }
    else {
        my $username = getline( $echobar, "Username: " );
        my $password = getline( $echobar, "Password: ", { password => 1 } );
        $base->userinfo("$username:$password");
    }

    $list_maxrows = $LINES - 3;

    @pages = list_pages();
    $pad   = create_pad(@pages);

    update_pad(1);

    while (1) {
        my $key = getchar;
        display_msg('');

        if ( my $funcname = $bindings{$key} ) {
            ## TODO Check if function exists on startup!
            no strict 'refs';
            &$funcname();
        }
        elsif ( $key eq KEY_RESIZE ) {
            resize_window();
        }
        else {
            display_msg("Key is not bound.");
        }
    }
}

sub first_item_on_page ($selected) {
    return int( $selected / $list_maxrows ) * $list_maxrows;
}

sub set_selected ($new) {
    return if !$pad;
    my $prev_selected = $selected;
    $selected = $new;
    if ( $selected < 0 ) {
        $selected = 0;
    }
    elsif ( $selected > @pages - 1 ) {
        $selected = @pages - 1;
    }
    if ( $prev_selected != $selected ) {
        chgat( $pad, $prev_selected, 0, -1, A_NORMAL, 0, 0 );
    }
    my $clear =
      first_item_on_page($prev_selected) != first_item_on_page($selected);
    update_pad($clear);
}

sub next_item {
    return if !$pad;
    set_selected( $selected + 1 );
}

sub prev_item {
    return if !$pad;
    set_selected( $selected - 1 );
}

sub next_page {
    return if !$pad;
    my $first_item_on_page = int( $selected / $list_maxrows ) * $list_maxrows;
    if ( @pages > $first_item_on_page + $list_maxrows ) {
        set_selected( $first_item_on_page + $list_maxrows );
    }
    else {
        set_selected( @pages - 1 );
    }
}

sub prev_page {
    return if !$pad;
    my $last_item_on_page =
      int( $selected / $list_maxrows ) * $list_maxrows - 1;
    if ( $last_item_on_page < 0 ) {
        set_selected(0);
    }
    else {
        set_selected($last_item_on_page);
    }
}

sub display_help {
    endwin;
    system( 'perldoc', $0 );
    update_pad(1);
    update_statusbar;
    update_helpbar;
}

sub view_page {
    my $page = $pages[$selected]->{title};
    my $res  = get( $base->clone->path("wiki/$page.json") );
    if ( !$res->is_success ) {
        display_msg( "Can't retrieve $page: " . $res->msg );
        return;
    }
    my $text = $res->json->{wiki_page}->{text};
    pager($text);
    update_pad(1);
    update_statusbar;
    update_helpbar;
}

sub edit_page {
    endwin;
    my $page = $pages[$selected]->{title};
    my $res  = get( $base->clone->path("wiki/$page.json") );
    if ( !$res->is_success ) {
        display_msg( "Can't retrieve $page: " . $res->msg );
        return;
    }
    my $text     = $res->json->{wiki_page}->{text};
    my $tempfile = tempfile;
    $tempfile->spurt( encode( 'utf8', $text ) );
    system( 'vim', $tempfile->to_string );
    update_pad(1);
    update_statusbar;
    update_helpbar;

    my $new_text = decode( 'utf8', $tempfile->slurp );

    if ( $new_text ne $text ) {
        if ( askyesno("Save page $page?") ) {
            put( $base->clone->path("wiki/$page.json"), $text );
        }
    }
    else {
        display_msg('Discard unmodified page.');
    }
}

sub search {
    my $query = getline( $echobar, "Search for pages matching: " );
    if ( $query eq 'all' ) {
        @pages = list_pages();
        update_pad(1);
    }
    elsif ( $query eq '' ) {
        display_msg('To view all messages, search for "all".');
    }
    else {
        my $url = $base->clone->path("search.json");
        $url->query->merge( q => $query, wiki_pages => 1 );
        my $res = get($url);
        my @found;
        my @results = @{ $res->json->{results} };
        if ( !@results ) {
            display_msg('No matches found.');
            return;
        }
        for my $result (@results) {
            $result->{title} =~ s/^Wiki: //;
            push @found, $pages{ $result->{title} };
        }
        @pages = @found;
        if ($pad) {
            delwin($pad);
        }
        $pad      = create_pad(@pages);
        $selected = 0;
        update_pad(1);
    }

}

sub quit {
    endwin;
    exit 0;
}

sub resize_window {
    update_pad(1);
    $list_maxrows = $LINES;
}

main();

__END__

=pod

=head1 NAME

pickaxe - the redmine editor

=head1 DESCRIPTION

Pickaxe is a terminal based programm to view and edit redmine wiki
pages.

=head1 DEFAULT BINDINGS

=over 4

=item s 

Search for wiki pages matching a pattern.

=item e

Edit wiki page under the cursor.

=item h 

Display this help.

=item q

Quit pickaxe.

=back

=head1 ENVIRONMENT

=over 4

=item REDMINE_APIKEY

This variable has to be set in order to access the redmine api. You can
access it by clicking on your account on your redmine wiki and search
for api key in the right margin.

=back
